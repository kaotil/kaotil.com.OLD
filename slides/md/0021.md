# My aws - データボリュームコンテナ編

@kaotil

2016/05/06



## データボリュームコンテナの使い道

データに永続性を持たせたい場合（データを保持し続けたい場合）、たとえばコンテナ間での共有や、データを保持しないコンテナから使うには、名前を付けたデータ・ボリューム・コンテナ（Data Volume Container）を作成し、そこにデータをマウントするのが良い方法です。

mysql のデータとかログとか入れるのにいいっぽい



## やりたい事

- データボリュームコンテナにソースを設置したい
- apache + php の1コンテナにしたい
- apache + php のコンテナからデータボリュームコンテナのソースを参照したい
  - これまではホスト上のディレクトリをデータボリュームとしてマウントしていた



## イメージ図

![Image](/slides/img/0021/image.png)<!-- .element: class="img_60" -->



## docker-compose ファイル構成

```
$ tree .
.
├── docker-compose.yml
├── storage
│   └── Dockerfile
└── web
    ├── Dockerfile
    ├── docker-php.conf
    └── kaotil-default.conf
```



### データボリュームコンテナ

- storage/Dockerfile

```
FROM alpine:latest
MAINTAINER kaotil

RUN apk add --update --no-cache git \
  && mkdir -p /opt/web
WORKDIR /opt/web
RUN git clone https://github.com/kaotil/kaotil.com.git

VOLUME /opt

CMD /bin/sh
```

Alpine はすっごく軽量なLinux



### apache + php Dockefile コンテナ

- web/Dockerfile

```
FROM php:7.1.3-apache
MAINTAINER kaotil

RUN apt-get update && apt-get install -y \
  vim \
  git \
  locales

RUN locale-gen ja_JP.UTF-8
ENV LANG ja_JP.UTF-8
ENV LANGUAGE ja_JP:en
ENV LC_ALL ja_JP.UTF-8
RUN localedef -f UTF-8 -i ja_JP ja_JP.UTF-8

RUN ln -fs /usr/share/zoneinfo/Asia/Tokyo /etc/localtime

COPY kaotil-default.conf /etc/apache2/sites-available/kaotil-default.conf
RUN sed -i 's/ServerTokens OS/ServerTokens Prod/' /etc/apache2/conf-available/security.conf
RUN sed -i 's/ServerSignature On/ServerSignature Off/' /etc/apache2/conf-available/security.conf
RUN a2ensite kaotil-default.conf
RUN a2dissite 000-default.conf
RUN a2enmod rewrite

CMD ["/usr/sbin/apache2ctl", "-D", "FOREGROUND"]

WORKDIR /opt/web
```

OS は debian、日本語化しておく



- web/docker-php.conf

```
<FilesMatch \.php$>
        SetHandler application/x-httpd-php
</FilesMatch>

DirectoryIndex disabled
DirectoryIndex index.php index.html

<Directory /opt/web/>
        Options -Indexes
        AllowOverride All
</Directory>
```



- web/kaotil-default.conf

```
<VirtualHost *:80>
    #ServerAdmin webmaster@localhost
    DocumentRoot /opt/web/kaotil.com

    <Directory /opt/web/kaotil.com>
        Options Indexes FollowSymLinks MultiViews
        AllowOverride All
        Require all granted
        RewriteEngine On
        RewriteRule ^slides/([0-9]+)$ /slides/slide.php?id=$1 [L]
    </Directory>

    ErrorLog ${APACHE_LOG_DIR}/error.log
    CustomLog ${APACHE_LOG_DIR}/access.log combined
    LogLevel info rewrite:trace8
</VirtualHost>
```




### docker-compose.yml ファイル

```
version: '2'
services:
  web:
    build: ./web
    hostname: web
    container_name: web
    ports:
      - '80:80'
    volumes_from:
      - storage
  storage:
    build: ./storage
    hostname: storage
    container_name: storage
```



## ビルドする

```
- ビルドと起動
$ docker-compose build
$ docker-compose up -d

- ビルドし直す場合
$ docker-compose stop
$ docker-compose rm
$ docker-compose build --no-cache
$ docker-compose up -d

- web コンテナにログインするには
$ docker exec -it web /bin/bash

- storage コンテナにログインするには
$ docker run --rm -it docker_storage sh

- イメージにソースが含まれているか確認
$ docker run --rm -it docker_storage ls -l /opt/web
```



## ECS リポジトリ作成



storageコンテナのリポジトリ

![strage retistry](/slides/img/0021/ecs_registry_storage.png)<!-- .element: class="img_80" -->



webコンテナのリポジトリ

![web retistry](/slides/img/0021/ecs_registry_web.png)<!-- .element: class="img_80" -->



イメージをリポジトリにプッシュ

```
$ aws ecr get-login --region ap-northeast-1
コマンドの戻り値のログインコマンドを実行

$ docker tag ecs_web:latest nnnnnnnnnnnn.dkr.ecr.ap-northeast-1.amazonaws.com/kaotil.com/web:latest
$ docker tag ecs_storage:latest nnnnnnnnnnnn.dkr.ecr.ap-northeast-1.amazonaws.com/kaotil.com/storage:latest

$ docker push nnnnnnnnnnnn.dkr.ecr.ap-northeast-1.amazonaws.com/kaotil.com/web:latest
$ docker push nnnnnnnnnnnn.dkr.ecr.ap-northeast-1.amazonaws.com/kaotil.com/storage:latest

- イメージにソースが含まれているか確認
$ docker run -it nnnnnnnnnnnn.dkr.ecr.ap-northeast-1.amazonaws.com/kaotil.com/storage ls -l /opt/web
```



## ECS クラスタ作成

![web cluster](/slides/img/0021/ecs_cluster.png)<!-- .element: class="img_50" -->



## ECS タスク作成

storage コンテナ 画面1

![web task storage1](/slides/img/0021/ecs_task_storage1.png)<!-- .element: class="img_70" -->



#### storage コンテナ 画面2

![web task storage2](/slides/img/0021/ecs_task_storage2.png)<!-- .element: class="img_50" -->

- [AWS テンプレートスニペット](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-ecs.html) のコマンド入れとかないとコンテナが起動しない？みたいな
- ローカルの Docker ではデータボリュームコンテナは起動してなくても使える



#### web コンテナ 画面1

![web task web1](/slides/img/0021/ecs_task_web1.png)<!-- .element: class="img_70" -->



#### web コンテナ 画面2

![web task web2](/slides/img/0021/ecs_task_web2.png)<!-- .element: class="img_70" -->



#### web コンテナ 画面3

![web task web3](/slides/img/0021/ecs_task_web3.png)<!-- .element: class="img_60" -->

- volume_from の設定をボリュームソースで設定



## ECS タスク実行

![web task execute](/slides/img/0021/ecs_task_exec.png)<!-- .element: class="img_70" -->



#### RUNNING になった

![web task execute result](/slides/img/0021/ecs_task_exec_result.png)<!-- .element: class="img_70" -->



### RUNNING にならない場合

```
- ECS ホストログイン
$ ssh ec2-user@<ECSホストのEIP> -i ~/.ssh/kaotil.pem 

- コンテナを確認
$ docker ps -a

- web コンテナ起動してみる
$ docker exec -it <コンテナ名> bash

- storage コンテナ起動してみる
$ docker exec -it <コンテナ名> sh

- ログを確認
$ docker logs <コンテナ名>
```



## ソースファイルの更新からデプロイまでの流れ



### ローカル環境で編集

```
- ローカルの storage コンテナにログイン
$ docker run -it <コンテナID> sh
ファイルを編集する

- Docker commit する
$ docker commit <コンテナID> ecs_storage:latest

- 追加したファイルがあるか確認する
$ docker run -it --rm <イメージID> ls -la /opt/web/kaotil.com/slides/md/0021.md
ls: /opt/web/kaotil.com/slides/md/0021.md: No such file or directory
追加したファイルがない

- /tmp/text.txt ファイルは保存されるか確認
$ docker run -it --rm e1fa3cccb5fd cat /tmp/test.txt
/tmp
保存されている

「構築ステップでボリューム内においてあらゆる変更を加えても、宣言後に内容は破棄されます。」
これってそういう意味か、、、
Dockerfile で 「VOLUME /opt」した以降は変更が破棄されるのな
```


### ローカル環境を変更

- ローカル開発用とECS用にイメージ分ける
- ローカルは、データボリュームにしてホスト上でファイル編集
  - その方がコンテナにログインしなくてもファイル編集できるし
- ファイルを更新して github にプッシュ
- ECS は storage コンテナを使用する
- ECS 用のイメージをビルドし直す
  - その際に最新ソースを git pull される
- docker-compose で毎回ビルドしてECR にアップする
- コンテナをデプロイする

```
- ビルドし直し
$ docker-compose stop
$ docker-compose rm
$ docker-compose build --no-cache

- ECR にプッシュ
$ aws ecr get-login --region ap-northeast-1
コマンドの戻り値のログインコマンドを実行
$ docker tag ecs_web:latest 631059538890.dkr.ecr.ap-northeast-1.amazonaws.com/kaotil.com/web:latest
$ docker tag ecs_storage:latest 631059538890.dkr.ecr.ap-northeast-1.amazonaws.com/kaotil.com/storage:latest
$ docker push 631059538890.dkr.ecr.ap-northeast-1.amazonaws.com/kaotil.com/web:latest
$ docker push 631059538890.dkr.ecr.ap-northeast-1.amazonaws.com/kaotil.com/storage:latest

- 手動デプロイ
AWS コンソール画面からタスクを解除して実行し直す
```



### 自動デプロイ

- IAM のcircleci ユーザにAmazonEC2ContainerServiceFullAccess を付与
- デプロイシェル [こちら](https://github.com/iron-breaker/go-ecs-ecr/blob/master/deploy.sh)を使わせてもらう

```
#!/usr/bin/env bash

# valiabls
AWS_DEFAULT_REGION=us-east-1
AWS_ECS_TASKDEF_NAME=nginx-sample-webapp
AWS_ECS_CLUSTER_NAME=sample-webapp-cluster
AWS_ECS_SERVICE_NAME=sample-webapp-service
AWS_ECR_REP_NAME=nginx-sample-webapp

# Create Task Definition
make_task_def(){
	task_template='[
		{
			"name": "%s",
			"image": "%s.dkr.ecr.%s.amazonaws.com/%s:%s",
			"essential": true,
			"memory": 200,
			"cpu": 10,
			"portMappings": [
				{
					"containerPort": 80,
					"hostPort": 80
				}
			]
		}
	]'

	task_def=$(printf "$task_template" ${AWS_ECS_TASKDEF_NAME} $AWS_ACCOUNT_ID ${AWS_DEFAULT_REGION} ${AWS_ECR_REP_NAME} $CIRCLE_SHA1)
}

# more bash-friendly output for jq
JQ="jq --raw-output --exit-status"

configure_aws_cli(){
	aws --version
	aws configure set default.region ${AWS_DEFAULT_REGION}
	aws configure set default.output json
}

deploy_cluster() {

    make_task_def
    register_definition
    if [[ $(aws ecs update-service --cluster ${AWS_ECS_CLUSTER_NAME} --service ${AWS_ECS_SERVICE_NAME} --task-definition $revision | \
                   $JQ '.service.taskDefinition') != $revision ]]; then
        echo "Error updating service."
        return 1
    fi

    # wait for older revisions to disappear
    # not really necessary, but nice for demos
    for attempt in {1..30}; do
        if stale=$(aws ecs describe-services --cluster ${AWS_ECS_CLUSTER_NAME} --services ${AWS_ECS_SERVICE_NAME} | \
                       $JQ ".services[0].deployments | .[] | select(.taskDefinition != \"$revision\") | .taskDefinition"); then
            echo "Waiting for stale deployments:"
            echo "$stale"
            sleep 5
        else
            echo "Deployed!"
            return 0
        fi
    done
    echo "Service update took too long."
    return 1
}


push_ecr_image(){
	eval $(aws ecr get-login --region ${AWS_DEFAULT_REGION})
	docker push $AWS_ACCOUNT_ID.dkr.ecr.us-east-1.amazonaws.com/${AWS_ECR_REP_NAME}:$CIRCLE_SHA1
}

register_definition() {

    if revision=$(aws ecs register-task-definition --container-definitions "$task_def" --family ${AWS_ECS_TASKDEF_NAME} | $JQ '.taskDefinition.taskDefinitionArn'); then
        echo "Revision: $revision"
    else
        echo "Failed to register task definition"
        return 1
    fi

}

configure_aws_cli
push_ecr_image
deploy_cluster
```


### 手動デプロイ

- ローカル環境では storage コンテナにログインしてファイル編集するのが面倒なので web コンテナとホストのボリュームを使っている

```
- storage コンテナにログインして最新ソースをpullする
$ docker run -it ecs_storage sh
$ git pull

CTRL + p + q で抜けます

$ docker commit dd6510d11bbd ecs_storage:latest

$ docker run -it nnnnnnnnnnnn.dkr.ecr.ap-northeast-1.amazonaws.com/kaotil.com/storage ls -l /opt/web
$ docker run -it --rm <イメージID> ls -l /opt/web/kaotil.com/slides/md/0021.md
```

- サービスの登録
- Circle CI で自動デプロイ
- タスクを web と storage に分けたい



## 備忘

```
- コンテナを削除する場合
 “宙づり”(dangling) ボリュームになってしまいます。宙づりボリュームは除去が大変なので注意
docker rm -v
```


## 参考サイト

- [CircleCI+ECS+ECR環境でDockerコンテナのCD(継続的デプロイ)環境を構築する -前編-](http://dev.classmethod.jp/cloud/circleci-ecr-ecs-1/)
- [CircleCI+ECS+ECR環境でDockerコンテナのCD(継続的デプロイ)環境を構築する -後編-](http://dev.classmethod.jp/cloud/httpdev-classmethod-jpcloudcircleci-ecr-ecs-2/)
- [Docker-docs-ja/Dockerfile リファレンス/VULUME](http://docs.docker.jp/engine/reference/builder.html?highlight=volume#volume)
