# My aws - データボリュームコンテナ編

@kaotil

2016/05/06



## データボリュームコンテナの使い道

データに永続性を持たせたい場合（データを保持し続けたい場合）、たとえばコンテナ間での共有や、データを保持しないコンテナから使うには、名前を付けたデータ・ボリューム・コンテナ（Data Volume Container）を作成し、そこにデータをマウントするのが良い方法です。

mysql のデータとかログとか入れるのにいいらしい



## やりたい事

- データボリュームコンテナにソースを設置したい
- apache + php の1コンテナにしたい
- apache + php のコンテナからデータボリュームコンテナのソースを参照したい
  - これまでは Docker ホスト上のディレクトリをデータボリュームとしてマウントしていた



## イメージ図

![Image](/slides/img/0021/image.png)<!-- .element: class="img_60" -->



## docker-compose ファイル構成

```
$ tree .
.
├── docker-compose.yml
├── storage
│   └── Dockerfile
└── web
    ├── Dockerfile
    ├── docker-php.conf
    └── kaotil-default.conf
```



### データボリュームコンテナ

- storage/Dockerfile

```
FROM alpine:latest
MAINTAINER kaotil

RUN apk add --update --no-cache git \
  && mkdir -p /opt/web
WORKDIR /opt/web
RUN git clone https://github.com/kaotil/kaotil.com.git

VOLUME /opt

CMD /bin/sh
```

ソースを git clone して VOLUME を定義する



### apache + php Dockefile コンテナ

- web/Dockerfile

```
FROM php:7.1.3-apache
MAINTAINER kaotil

RUN apt-get update && apt-get install -y \
  vim \
  git \
  locales

RUN locale-gen ja_JP.UTF-8
ENV LANG ja_JP.UTF-8
ENV LANGUAGE ja_JP:en
ENV LC_ALL ja_JP.UTF-8
RUN localedef -f UTF-8 -i ja_JP ja_JP.UTF-8

RUN ln -fs /usr/share/zoneinfo/Asia/Tokyo /etc/localtime

COPY kaotil-default.conf /etc/apache2/sites-available/kaotil-default.conf
RUN sed -i 's/ServerTokens OS/ServerTokens Prod/' /etc/apache2/conf-available/security.conf
RUN sed -i 's/ServerSignature On/ServerSignature Off/' /etc/apache2/conf-available/security.conf
RUN a2ensite kaotil-default.conf
RUN a2dissite 000-default.conf
RUN a2enmod rewrite

CMD ["/usr/sbin/apache2ctl", "-D", "FOREGROUND"]

WORKDIR /opt/web
```

OS は debian、日本語化しておく



- web/docker-php.conf

```
<FilesMatch \.php$>
        SetHandler application/x-httpd-php
</FilesMatch>

DirectoryIndex disabled
DirectoryIndex index.php index.html

<Directory /opt/web/>
        Options -Indexes
        AllowOverride All
</Directory>
```



- web/kaotil-default.conf

```
<VirtualHost *:80>
    #ServerAdmin webmaster@localhost
    DocumentRoot /opt/web/kaotil.com

    <Directory /opt/web/kaotil.com>
        Options Indexes FollowSymLinks MultiViews
        AllowOverride All
        Require all granted
        RewriteEngine On
        RewriteRule ^slides/([0-9]+)$ /slides/slide.php?id=$1 [L]
    </Directory>

    ErrorLog ${APACHE_LOG_DIR}/error.log
    CustomLog ${APACHE_LOG_DIR}/access.log combined
    LogLevel info rewrite:trace8
</VirtualHost>
```




### docker-compose.yml ファイル

```
version: '2'
services:
  web:
    build: ./web
    hostname: web
    container_name: web
    ports:
      - '80:80'
    volumes_from:
      - storage
  storage:
    build: ./storage
    hostname: storage
    container_name: storage
```

webコンテナの volumes_from で storage の volume を参照する



## ビルドする

```
- ビルドと起動
$ docker-compose build
$ docker-compose up -d

- ビルドし直す場合
$ docker-compose stop
$ docker-compose rm
$ docker-compose build --no-cache
$ docker-compose up -d

- web コンテナにログインするには
$ docker exec -it web /bin/bash

- storage コンテナにログインするには
$ docker run --rm -it docker_storage sh

- イメージにソースが含まれているか確認
$ docker run --rm -it docker_storage ls -l /opt/web
```



## ECS リポジトリ作成



storageコンテナのリポジトリ

![strage retistry](/slides/img/0021/ecs_registry_storage.png)<!-- .element: class="img_80" -->



webコンテナのリポジトリ

![web retistry](/slides/img/0021/ecs_registry_web.png)<!-- .element: class="img_80" -->



イメージをリポジトリにプッシュ

```
$ aws ecr get-login --region ap-northeast-1
コマンドの戻り値のログインコマンドを実行

$ docker tag ecs_web:latest nnnnnnnnnnnn.dkr.ecr.ap-northeast-1.amazonaws.com/kaotil.com/web:latest
$ docker tag ecs_storage:latest nnnnnnnnnnnn.dkr.ecr.ap-northeast-1.amazonaws.com/kaotil.com/storage:latest

$ docker push nnnnnnnnnnnn.dkr.ecr.ap-northeast-1.amazonaws.com/kaotil.com/web:latest
$ docker push nnnnnnnnnnnn.dkr.ecr.ap-northeast-1.amazonaws.com/kaotil.com/storage:latest

- イメージにソースが含まれているか確認
$ docker run -it --rm nnnnnnnnnnnn.dkr.ecr.ap-northeast-1.amazonaws.com/kaotil.com/storage ls -l /opt/web
```



## ECS クラスタ作成

![web cluster](/slides/img/0021/ecs_cluster.png)<!-- .element: class="img_50" -->



## ECS タスク作成

storage コンテナ 画面1

![web task storage1](/slides/img/0021/ecs_task_storage1.png)<!-- .element: class="img_70" -->



#### storage コンテナ 画面2

![web task storage2](/slides/img/0021/ecs_task_storage2.png)<!-- .element: class="img_50" -->

- [AWS テンプレートスニペット](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-ecs.html) みたいにコマンド入れとかないとコンテナが起動したままにならない
- ローカルの Docker ではデータボリュームコンテナは起動してなくても使える ESCでは起動してないとダメみたい



#### web コンテナ 画面1

![web task web1](/slides/img/0021/ecs_task_web1.png)<!-- .element: class="img_70" -->



#### web コンテナ 画面2

![web task web2](/slides/img/0021/ecs_task_web2.png)<!-- .element: class="img_70" -->



#### web コンテナ 画面3

![web task web3](/slides/img/0021/ecs_task_web3.png)<!-- .element: class="img_60" -->

- volume_from の設定をボリュームソースで設定



### ECS タスク作成

![web task create](/slides/img/0021/ecs_task_create.png)<!-- .element: class="img_70" -->



### ECS サービス作成

![web service](/slides/img/0021/ecs_service.png)<!-- .element: class="img_70" -->



#### RUNNING になってサイトが見れるようになった

![web task execute result](/slides/img/0021/ecs_task_exec_result.png)<!-- .element: class="img_70" -->



#### RUNNING にならない場合

```
- ECS ホストログイン
$ ssh ec2-user@<ECSホストのEIP> -i ~/.ssh/.pem 

- コンテナを確認
$ docker ps -a

- web コンテナ起動してみる
$ docker exec -it <コンテナ名> bash

- storage コンテナ起動してみる
$ docker exec -it <コンテナ名> sh

- ログを確認
$ docker logs <コンテナ名>
```



## デプロイまでの流れ

0. storage コンテナ内でソースファイルの編集
0. docker commit
0. docker tag でタグ付け
0. ECR にイメージをプッシュ
0. ECS タスクを新イメージで作成
0. ECS サービスの更新でデプロイ



### が、これではダメだった、、、

[公式ドキュメント](http://docs.docker.jp/engine/reference/builder.html?highlight=volume#volume)に

> 注釈
> 構築ステップでボリューム内においてあらゆる変更を加えても、宣言後に内容は破棄されます。



#### Dockerfile で 「VOLUME /opt」した以降は変更が破棄されるのか、ショック！！



### ということで、試行錯誤の最終形

0. ローカルでファイルを編集
0. github にプッシュ
0. CircleCI で自動デプロイ、以下 CircleCI 上で実行
  0. Docker イメージをビルド
  0. ECR にイメージをプッシュ
  0. ESC のサービスを更新してデプロイ



### CircleCI で自動デプロイ

- IAM のcircleci ユーザにAmazonEC2ContainerServiceFullAccess を付与
- デプロイシェル [こちら](https://github.com/iron-breaker/go-ecs-ecr/blob/master/deploy.sh)を参考にして作成

```
```




## 備忘

```
- コンテナを削除する場合
 “宙づり”(dangling) ボリュームになってしまいます。宙づりボリュームは除去が大変なので注意
docker rm -v
```


## 参考サイト

- [CircleCI+ECS+ECR環境でDockerコンテナのCD(継続的デプロイ)環境を構築する -前編-](http://dev.classmethod.jp/cloud/circleci-ecr-ecs-1/)
- [CircleCI+ECS+ECR環境でDockerコンテナのCD(継続的デプロイ)環境を構築する -後編-](http://dev.classmethod.jp/cloud/httpdev-classmethod-jpcloudcircleci-ecr-ecs-2/)
- [Docker-docs-ja/Dockerfile リファレンス/VULUME](http://docs.docker.jp/engine/reference/builder.html?highlight=volume#volume)
